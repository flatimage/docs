{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlatImage What is it? FlatImage, is a hybrid of Flatpak sandboxing with AppImage portability. FlatImage use case is twofold: Flatimage is a package format, it includes a piece of software with all its dependencies for it work with across several linux distros (both Musl and GNU). Unlike AppImage , FlatImage runs the application in a container by default, which increases portability and compatibility at the cost of file size. Flatimage is a portable container image that requires no superuser permissions to run. The diverse GNU/Linux ecosystem includes a vast array of distributions, each with its own advantages and use cases. This can lead to cross-distribution software compatibility challenges. FlatImage addresses these issues by: Utilizing its own root directory, enabling dynamic libraries with hard-coded paths to be packaged alongside the software without binary patching . Running the application in its own gnu (or musl) environment, therefore, not using host libraries that might be outdated/incompatiblesystem with the application. It simplifies the task of software packaging by enforcing the philosophy that it should be as simple as setting up a container. This is an effort for the end-user to not depend on the application developer to provide the portable binary (or to handle how to package the application, dependencies and create a runner script). It also increases the quality of life of the package developer, simplifying the packaging process of applications. How to use Get FlatImage Download a flatimage package from the releases , your available options are: arch.flatimage alpine.flatimage blueprint.flatimage arch is a complete GNU archlinux subsystem with the pacman package manager. alpine is a complete MUSL alpine subsystem with the apk package manager. blueprint is a flatimage without a system to build a package with only the bare minimum for the application to work, making it lightweight in file size. Execute The Container With arch.flatimage as an example, you can enter the container simply by executing the binary file: $ chmod +x ./arch.flatimage $ ./arch.flatimage [flatimage-arch] / \u2192 To exit the container, just press CTRL+D . To download packages please enable the network permission with: $ ./arch.flatimage fim-perms add network Go to the fim-perms help page for more details. How it works A FlatImage uses a container where it executes its own commands apart from the host system. With that in mind, it is possible to package applications that run in different linux distributions without worrying about missing binaries or libraries. Motivations The idea of this application sprung with the challenge to package software and dynamic libraries, such as wine , when there are hard-coded paths. The best solution is invasive https://github.com/AppImage/AppImageKit/wiki/Bundling-Windows-applications , which patches the binaries of wine directly to use a custom path for the 32-bit libraries (an implementation of this concept is available here ), not only that, it requires to patch the 32-bit pre-loader ld-linux.so as well, however, sometimes it still fails to execute properly. This is an over exceeding complexity for the end-user, which should package applications with no effort; FlatImage changes the root filesystem the application runs in, to a minimal gnu subsystem, and with that, it solves the previous issues with dynamic libraries no workarounds required. No host libraries are used, which decreases issues of portable applications working on one machine and not in other. The fragmentation of the linux package management is considerable in modern times, e.g., apt , pip , npm , and more. To mitigate this issue FlatImage can perform the installation through the preferred package manager, and turn the program into an executable file, that can run in any linux distribution. E.g.: The user of FlatImage can create a binary of youtube-dl , from the pip package manager, without having either pip or python installed on the host operating system. Some applications are offered as pre-compiled compressed tar files (tarballs), which sometimes only work when installed on the root of the operating system. However, doing so could hinder the operating system integrity, to avoid this issue FlatImage can install tarballs into itself and turn them into a portable binary. Related Projects https://github.com/Kron4ek/Conty https://github.com/genuinetools/binctr https://github.com/Intoli/exodus https://statifier.sourceforge.net/ https://github.com/matthewbauer/nix-bundle https://github.com/containers/bubblewrap https://github.com/proot-me/proot","title":"FlatImage"},{"location":"#flatimage","text":"","title":"FlatImage"},{"location":"#what-is-it","text":"FlatImage, is a hybrid of Flatpak sandboxing with AppImage portability. FlatImage use case is twofold: Flatimage is a package format, it includes a piece of software with all its dependencies for it work with across several linux distros (both Musl and GNU). Unlike AppImage , FlatImage runs the application in a container by default, which increases portability and compatibility at the cost of file size. Flatimage is a portable container image that requires no superuser permissions to run. The diverse GNU/Linux ecosystem includes a vast array of distributions, each with its own advantages and use cases. This can lead to cross-distribution software compatibility challenges. FlatImage addresses these issues by: Utilizing its own root directory, enabling dynamic libraries with hard-coded paths to be packaged alongside the software without binary patching . Running the application in its own gnu (or musl) environment, therefore, not using host libraries that might be outdated/incompatiblesystem with the application. It simplifies the task of software packaging by enforcing the philosophy that it should be as simple as setting up a container. This is an effort for the end-user to not depend on the application developer to provide the portable binary (or to handle how to package the application, dependencies and create a runner script). It also increases the quality of life of the package developer, simplifying the packaging process of applications.","title":"What is it?"},{"location":"#how-to-use","text":"Get FlatImage Download a flatimage package from the releases , your available options are: arch.flatimage alpine.flatimage blueprint.flatimage arch is a complete GNU archlinux subsystem with the pacman package manager. alpine is a complete MUSL alpine subsystem with the apk package manager. blueprint is a flatimage without a system to build a package with only the bare minimum for the application to work, making it lightweight in file size. Execute The Container With arch.flatimage as an example, you can enter the container simply by executing the binary file: $ chmod +x ./arch.flatimage $ ./arch.flatimage [flatimage-arch] / \u2192 To exit the container, just press CTRL+D . To download packages please enable the network permission with: $ ./arch.flatimage fim-perms add network Go to the fim-perms help page for more details.","title":"How to use"},{"location":"#how-it-works","text":"A FlatImage uses a container where it executes its own commands apart from the host system. With that in mind, it is possible to package applications that run in different linux distributions without worrying about missing binaries or libraries.","title":"How it works"},{"location":"#motivations","text":"The idea of this application sprung with the challenge to package software and dynamic libraries, such as wine , when there are hard-coded paths. The best solution is invasive https://github.com/AppImage/AppImageKit/wiki/Bundling-Windows-applications , which patches the binaries of wine directly to use a custom path for the 32-bit libraries (an implementation of this concept is available here ), not only that, it requires to patch the 32-bit pre-loader ld-linux.so as well, however, sometimes it still fails to execute properly. This is an over exceeding complexity for the end-user, which should package applications with no effort; FlatImage changes the root filesystem the application runs in, to a minimal gnu subsystem, and with that, it solves the previous issues with dynamic libraries no workarounds required. No host libraries are used, which decreases issues of portable applications working on one machine and not in other. The fragmentation of the linux package management is considerable in modern times, e.g., apt , pip , npm , and more. To mitigate this issue FlatImage can perform the installation through the preferred package manager, and turn the program into an executable file, that can run in any linux distribution. E.g.: The user of FlatImage can create a binary of youtube-dl , from the pip package manager, without having either pip or python installed on the host operating system. Some applications are offered as pre-compiled compressed tar files (tarballs), which sometimes only work when installed on the root of the operating system. However, doing so could hinder the operating system integrity, to avoid this issue FlatImage can install tarballs into itself and turn them into a portable binary.","title":"Motivations"},{"location":"#related-projects","text":"https://github.com/Kron4ek/Conty https://github.com/genuinetools/binctr https://github.com/Intoli/exodus https://statifier.sourceforge.net/ https://github.com/matthewbauer/nix-bundle https://github.com/containers/bubblewrap https://github.com/proot-me/proot","title":"Related Projects"},{"location":"comparison/","text":"Comparison with other available tools Feature FlatImage Docker AppImage No superuser privileges to use x x 2 x Overlayfs (allows to install programs even after compression) x No installation necessary (click and use) x Requires docker on the host x Requires building on an old system to minimize glibc issues N/A x Mountable as a filesystem x x x 3 Runs without mounting the filesystem x Straightforward build process x x Desktop integration x x Extract the contents x x x Supports reconfiguration without rebuild x x (layers) No host libraries used (Filesystem Isolation) x x Supports compression of specific directories/files in the package x Portable mutable user configuration x x Granular control over containerization x x Works without fuse installed (still requires kernel support) x 4 x x 5 Layered filesystem x (overlayfs) x Advanced networking management x Advanced security features x Requires superuser privileges Only if the user is part of the docker group Only as read-only, you can mount FIM as read-write, before compression. Works without libfuse/libfuse3, still requires fusermount to be available. Experimental implementations, available here and here","title":"Comparison with other available tools"},{"location":"comparison/#comparison-with-other-available-tools","text":"Feature FlatImage Docker AppImage No superuser privileges to use x x 2 x Overlayfs (allows to install programs even after compression) x No installation necessary (click and use) x Requires docker on the host x Requires building on an old system to minimize glibc issues N/A x Mountable as a filesystem x x x 3 Runs without mounting the filesystem x Straightforward build process x x Desktop integration x x Extract the contents x x x Supports reconfiguration without rebuild x x (layers) No host libraries used (Filesystem Isolation) x x Supports compression of specific directories/files in the package x Portable mutable user configuration x x Granular control over containerization x x Works without fuse installed (still requires kernel support) x 4 x x 5 Layered filesystem x (overlayfs) x Advanced networking management x Advanced security features x Requires superuser privileges Only if the user is part of the docker group Only as read-only, you can mount FIM as read-write, before compression. Works without libfuse/libfuse3, still requires fusermount to be available. Experimental implementations, available here and here","title":"Comparison with other available tools"},{"location":"portal/","text":"Transparent Command Portal What is it? Flatimage has a portal mechanism to execute commands in host machine, the output and return code is returned in the guest as if the command was executed in it (thus transparent). How to Use Examples: Check if the host contains the thunar file manager: fim_portal sh -c 'command -v thunar' Open thunar in the host machine: fim_portal thunar Open thunar in the host machine (full path): fim_portal /bin/thunar Open the desktop folder with thunar on the host machine: fim_portal thunar ~/Desktop How it Works Three FIFOs are created, for stdout , stderr and the exit code , the guest connects to the stdout and stderr FIFOs as a reader. The command to be executed in the host machine and the paths to the FIFOs are serialized to the host daemon; the daemon creates a child process and replaces its stdout and stderr pipes with the provided FIFOs. After the command is finished, the exit code is sent through the exit pipe and the guest process exits with the same code returned from the child host process.","title":"Transparent Command Portal"},{"location":"portal/#transparent-command-portal","text":"","title":"Transparent Command Portal"},{"location":"portal/#what-is-it","text":"Flatimage has a portal mechanism to execute commands in host machine, the output and return code is returned in the guest as if the command was executed in it (thus transparent).","title":"What is it?"},{"location":"portal/#how-to-use","text":"Examples: Check if the host contains the thunar file manager: fim_portal sh -c 'command -v thunar' Open thunar in the host machine: fim_portal thunar Open thunar in the host machine (full path): fim_portal /bin/thunar Open the desktop folder with thunar on the host machine: fim_portal thunar ~/Desktop","title":"How to Use"},{"location":"portal/#how-it-works","text":"Three FIFOs are created, for stdout , stderr and the exit code , the guest connects to the stdout and stderr FIFOs as a reader. The command to be executed in the host machine and the paths to the FIFOs are serialized to the host daemon; the daemon creates a child process and replaces its stdout and stderr pipes with the provided FIFOs. After the command is finished, the exit code is sent through the exit pipe and the guest process exits with the same code returned from the child host process.","title":"How it Works"},{"location":"cmd/bind/","text":"Bind Host Paths What is it? This is a mechanism to make specific paths from the host available inside the guest container. How to use You can use ./app.flatimage fim-help env to get the following usage details: fim-bind : Bind paths from the host to inside the container Commands: add,del,list, add : Create a novel binding of type <type> from <src> to <dst> del : Deletes a binding with the specified index list : List current bindings Usage: fim-bind add <type> <src> <dst> <type> : ro, rw, dev <src> : A file, directory, or device <dst> : A file, directory, or device Usage: fim-bind del <index> <index> : Index of the binding to erase Usage: fim-bind list To bind a device from the host to use in the guest: $ ./app.flatimage fim-bind add dev /dev/my_device /dev/my_device This will make my_device available inside the container. To bind a file path from the host to the guest as read-only: $ ./app.flatimage fim-bind add ro '$HOME/Music' /Music This will make the Music directory available inside the container in /Music , as read-only. Notice that '$HOME/Music' is inside single quotes, this means that the $HOME variable will only expand when flatimage is executed; i.e., when another user executes the app , their $HOME/Music directory will be the one bound to the container. To bind a file path from the host to the guest as read-write: $ ./app.flatimage fim-bind add rw '$HOME/Music' /Music This will make the Music directory available inside the container in /Music , as read-write. You can list the current bindings with the list command: $ ./app.flatimage fim-bind list { \"1\": { \"dst\": \"/dev/video0\", \"src\": \"/dev/video0\", \"type\": \"dev\" }, \"2\": { \"dst\": \"/Music\", \"src\": \"$HOME/Music\", \"type\": \"ro\" } } You can erase a binding with the del command, which takes and index as argument. $ ./app.flatimage fim-bind del 2 $ ./app.flatimage fim-bind list { \"1\": { \"dst\": \"/dev/video0\", \"src\": \"/dev/video0\", \"type\": \"dev\" } } How it works FlatImage uses bubblewrap's bind mechanisms to make devices and directories available in the guest container.","title":"fim-bind"},{"location":"cmd/bind/#bind-host-paths","text":"","title":"Bind Host Paths"},{"location":"cmd/bind/#what-is-it","text":"This is a mechanism to make specific paths from the host available inside the guest container.","title":"What is it?"},{"location":"cmd/bind/#how-to-use","text":"You can use ./app.flatimage fim-help env to get the following usage details: fim-bind : Bind paths from the host to inside the container Commands: add,del,list, add : Create a novel binding of type <type> from <src> to <dst> del : Deletes a binding with the specified index list : List current bindings Usage: fim-bind add <type> <src> <dst> <type> : ro, rw, dev <src> : A file, directory, or device <dst> : A file, directory, or device Usage: fim-bind del <index> <index> : Index of the binding to erase Usage: fim-bind list To bind a device from the host to use in the guest: $ ./app.flatimage fim-bind add dev /dev/my_device /dev/my_device This will make my_device available inside the container. To bind a file path from the host to the guest as read-only: $ ./app.flatimage fim-bind add ro '$HOME/Music' /Music This will make the Music directory available inside the container in /Music , as read-only. Notice that '$HOME/Music' is inside single quotes, this means that the $HOME variable will only expand when flatimage is executed; i.e., when another user executes the app , their $HOME/Music directory will be the one bound to the container. To bind a file path from the host to the guest as read-write: $ ./app.flatimage fim-bind add rw '$HOME/Music' /Music This will make the Music directory available inside the container in /Music , as read-write. You can list the current bindings with the list command: $ ./app.flatimage fim-bind list { \"1\": { \"dst\": \"/dev/video0\", \"src\": \"/dev/video0\", \"type\": \"dev\" }, \"2\": { \"dst\": \"/Music\", \"src\": \"$HOME/Music\", \"type\": \"ro\" } } You can erase a binding with the del command, which takes and index as argument. $ ./app.flatimage fim-bind del 2 $ ./app.flatimage fim-bind list { \"1\": { \"dst\": \"/dev/video0\", \"src\": \"/dev/video0\", \"type\": \"dev\" } }","title":"How to use"},{"location":"cmd/bind/#how-it-works","text":"FlatImage uses bubblewrap's bind mechanisms to make devices and directories available in the guest container.","title":"How it works"},{"location":"cmd/commit/","text":"Commit current changes to the FlatImage What is it? fim-commit is a command to integrate the current changes with the FlatImage. How to Use # Allow network access ./app.flatimage fim-perms add network # Install firefox ./app.flatimage fim-root pacman -S firefox # Compress firefox and its dependencies into a new layer, and include it in the flatimage ./app.flatimage fim-commit How it Works fim-commit compresses the modified and/or newly created files from the overlay filesystem into a new layer; afterwards, it includes this layer in the top of the layer stack of the current image.","title":"fim-commit"},{"location":"cmd/commit/#commit-current-changes-to-the-flatimage","text":"","title":"Commit current changes to the FlatImage"},{"location":"cmd/commit/#what-is-it","text":"fim-commit is a command to integrate the current changes with the FlatImage.","title":"What is it?"},{"location":"cmd/commit/#how-to-use","text":"# Allow network access ./app.flatimage fim-perms add network # Install firefox ./app.flatimage fim-root pacman -S firefox # Compress firefox and its dependencies into a new layer, and include it in the flatimage ./app.flatimage fim-commit","title":"How to Use"},{"location":"cmd/commit/#how-it-works","text":"fim-commit compresses the modified and/or newly created files from the overlay filesystem into a new layer; afterwards, it includes this layer in the top of the layer stack of the current image.","title":"How it Works"},{"location":"cmd/desktop/","text":"Desktop Integration What is it? The desktop integration allows flatimage programs to integrate themselves into the start menu, show the application icon in the file manager and also define its own mimetype. How to Use Configure You can use ./app.flatimage fim-help desktop to get the following usage details: fim-desktop: Configure the desktop integration Usage: fim-desktop setup <json-file> fim-desktop enable <items...> items: entry,mimetype,icon Example: fim-desktop enable entry,mimetype,icon To setup the desktop integration for a flatimage package, the first step is to create a json file with the integration data, assume we create a file named desktop.json with the following contents: { \"name\": \"MyApp\", \"icon\": \"./my_app.png\", \"categories\": [\"System\",\"Audio\"] } This example creates the integration data for the application MyApp , with the icon file my_app.png located in the same folder as desktop.json . The categories field is used for the desktop menu entry integration, a list of valid categories is found here . Let's assume the json file is called desktop.json and the flatimage file is called app.flatimage , the next command uses the desktop.json file to configure the desktop integration. $ ./app.flatimage fim-desktop setup ./desktop.json After the setup step, you can enable the integration selectively, entry refers to the desktop entry in the start menu, mimetype refers to the file type that appears in the file manager, icon is the application icon shown in the start menu and the file manager. Here's how to enable everything: $ ./app.flatimage fim-desktop enable entry,mimetype,icon Erase entries To erase all desktop entries and icons created by flatimage, you can use the command: $ find ~/.local/share -iname \"*flatimage*\" -exec rm -v \"{}\" \\; xdg-open Flatimage redirects xdg-open commands to the host machine Examples: Open a video file with the host default video player: xdg-open my-file.mkv Open a link with the host default browser: xdg-open www.google.com How it Works FlatImage installs desktop entries in $HOME/.local/share/applications , icons are installed in $HOME/.local/share/icons and mimetypes are installed in $HOME/.local/share/mime . The user must define XDG_DATA_HOME to $HOME/.local/share or XDG_DATA_DIRS to contain the path $HOME/.local/share .","title":"fim-desktop"},{"location":"cmd/desktop/#desktop-integration","text":"","title":"Desktop Integration"},{"location":"cmd/desktop/#what-is-it","text":"The desktop integration allows flatimage programs to integrate themselves into the start menu, show the application icon in the file manager and also define its own mimetype.","title":"What is it?"},{"location":"cmd/desktop/#how-to-use","text":"Configure You can use ./app.flatimage fim-help desktop to get the following usage details: fim-desktop: Configure the desktop integration Usage: fim-desktop setup <json-file> fim-desktop enable <items...> items: entry,mimetype,icon Example: fim-desktop enable entry,mimetype,icon To setup the desktop integration for a flatimage package, the first step is to create a json file with the integration data, assume we create a file named desktop.json with the following contents: { \"name\": \"MyApp\", \"icon\": \"./my_app.png\", \"categories\": [\"System\",\"Audio\"] } This example creates the integration data for the application MyApp , with the icon file my_app.png located in the same folder as desktop.json . The categories field is used for the desktop menu entry integration, a list of valid categories is found here . Let's assume the json file is called desktop.json and the flatimage file is called app.flatimage , the next command uses the desktop.json file to configure the desktop integration. $ ./app.flatimage fim-desktop setup ./desktop.json After the setup step, you can enable the integration selectively, entry refers to the desktop entry in the start menu, mimetype refers to the file type that appears in the file manager, icon is the application icon shown in the start menu and the file manager. Here's how to enable everything: $ ./app.flatimage fim-desktop enable entry,mimetype,icon Erase entries To erase all desktop entries and icons created by flatimage, you can use the command: $ find ~/.local/share -iname \"*flatimage*\" -exec rm -v \"{}\" \\; xdg-open Flatimage redirects xdg-open commands to the host machine Examples: Open a video file with the host default video player: xdg-open my-file.mkv Open a link with the host default browser: xdg-open www.google.com","title":"How to Use"},{"location":"cmd/desktop/#how-it-works","text":"FlatImage installs desktop entries in $HOME/.local/share/applications , icons are installed in $HOME/.local/share/icons and mimetypes are installed in $HOME/.local/share/mime . The user must define XDG_DATA_HOME to $HOME/.local/share or XDG_DATA_DIRS to contain the path $HOME/.local/share .","title":"How it Works"},{"location":"cmd/environment/","text":"Environment Variables What is it? FlatImage provides a number of environment variables to query information about directories, version, etc. These are separated in two groups, modifiable and read-only: Modifiable : FIM_DEBUG : If defined to 1, print debug messages. FIM_MAIN_OFFSET : Shows filesystem offset and exits. Read-Only : FIM_VERSION : The version of the flatimage package FIM_DIST : The linux distribution name (alpine, arch) FIM_FILE_BINARY : Full path to the flatimage file FIM_DIR_TEMP : Location of the runtime directory for instances of the current flatimage FIM_DIR_MOUNT : Location of the runtime flatimage mountpoint FIM_DIR_HOST_CONFIG : Configuration directory in the host machine Furthermore, FlatImage also allows to the user to set the their own environment variables. How to use You can use ./app.flatimage fim-help env to get the following usage details: Flatimage - Portable Linux Applications fim-env: Edit current permissions for the flatimage Usage: fim-env add|set <'key=value'>... fim-env del <key>... fim-env list Example: fim-env add 'APP_NAME=hello-world' 'PS1=my-app> ' 'HOME=$FIM_DIR_HOST_CONFIG/home' The env command allows you to set new environment variables as so: $ ./app.flatimage fim-env add 'MY_NAME=user' 'MY_STATE=sad' You can change the value of the PS1 variable for a custom prompt for your application, the Appendix contains the options reference. $ ./app.flatimage fim-env set 'PS1=\"[\\#] \\A \\W -> \"' To use these variables in the default boot command: $ ./app.flatimage fim-boot sh -c 'echo \"My name is $MY_NAME and I am $MY_STATE\"' $ ./app.flatimage My name is user and I am sad To list the set variables: $ ./app.flatimage fim-env list MY_NAME=user MY_STATE=sad To delete the set variables: $ ./app.flatimage fim-env del MY_NAME MY_STATE To enable debugging you can use: $ FIM_DEBUG=1 ./app.flatimage # or $ export FIM_DEBUG=1 $ ./app.flatimage How it works FlatImage defines environment variables during its boot process, they are used to convey information about the directories to mount filesystems and query data. Appendix Details for PS1 configuration: PROMPTING When executing interactively, bash displays the primary prompt PS1 when it is ready to read a command, and the secondary prompt PS2 when it needs more input to complete a command. Bash displays PS0 after it reads a command but before executing it. Bash displays PS4 as described above before tracing each command when the -x option is enabled. Bash allows these prompt strings to be customized by inserting a number of backslash-escaped special char\u2010 acters that are decoded as follows: \\a an ASCII bell character (07) \\d the date in \"Weekday Month Date\" format (e.g., \"Tue May 26\") \\D{format} the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required \\e an ASCII escape character (033) \\h the hostname up to the first \u2018.' \\H the hostname \\j the number of jobs currently managed by the shell \\l the basename of the shell's terminal device name \\n newline \\r carriage return \\s the name of the shell, the basename of $0 (the portion following the final slash) \\t the current time in 24-hour HH:MM:SS format \\T the current time in 12-hour HH:MM:SS format \\@ the current time in 12-hour am/pm format \\A the current time in 24-hour HH:MM format \\u the username of the current user \\v the version of bash (e.g., 2.00) \\V the release of bash, version + patch level (e.g., 2.00.0) \\w the value of the PWD shell variable ($PWD), with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable) \\W the basename of $PWD, with $HOME abbreviated with a tilde \\! the history number of this command \\# the command number of this command \\$ if the effective UID is 0, a #, otherwise a $ \\nnn the character corresponding to the octal number nnn \\\\ a backslash \\[ begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt \\] end a sequence of non-printing characters The command number and the history number are usually different: the history number of a command is its position in the history list, which may include commands restored from the history file (see HISTORY below), while the command number is the position in the sequence of commands executed during the current shell session. After the string is decoded, it is expanded via parameter expansion, command substitution, arithmetic expansion, and quote re\u2010 moval, subject to the value of the promptvars shell option (see the description of the shopt command under SHELL BUILTIN COMMANDS below). This can have unwanted side effects if escaped portions of the string appear within command substitution or contain characters special to word expansion.","title":"fim-env"},{"location":"cmd/environment/#environment-variables","text":"","title":"Environment Variables"},{"location":"cmd/environment/#what-is-it","text":"FlatImage provides a number of environment variables to query information about directories, version, etc. These are separated in two groups, modifiable and read-only: Modifiable : FIM_DEBUG : If defined to 1, print debug messages. FIM_MAIN_OFFSET : Shows filesystem offset and exits. Read-Only : FIM_VERSION : The version of the flatimage package FIM_DIST : The linux distribution name (alpine, arch) FIM_FILE_BINARY : Full path to the flatimage file FIM_DIR_TEMP : Location of the runtime directory for instances of the current flatimage FIM_DIR_MOUNT : Location of the runtime flatimage mountpoint FIM_DIR_HOST_CONFIG : Configuration directory in the host machine Furthermore, FlatImage also allows to the user to set the their own environment variables.","title":"What is it?"},{"location":"cmd/environment/#how-to-use","text":"You can use ./app.flatimage fim-help env to get the following usage details: Flatimage - Portable Linux Applications fim-env: Edit current permissions for the flatimage Usage: fim-env add|set <'key=value'>... fim-env del <key>... fim-env list Example: fim-env add 'APP_NAME=hello-world' 'PS1=my-app> ' 'HOME=$FIM_DIR_HOST_CONFIG/home' The env command allows you to set new environment variables as so: $ ./app.flatimage fim-env add 'MY_NAME=user' 'MY_STATE=sad' You can change the value of the PS1 variable for a custom prompt for your application, the Appendix contains the options reference. $ ./app.flatimage fim-env set 'PS1=\"[\\#] \\A \\W -> \"' To use these variables in the default boot command: $ ./app.flatimage fim-boot sh -c 'echo \"My name is $MY_NAME and I am $MY_STATE\"' $ ./app.flatimage My name is user and I am sad To list the set variables: $ ./app.flatimage fim-env list MY_NAME=user MY_STATE=sad To delete the set variables: $ ./app.flatimage fim-env del MY_NAME MY_STATE To enable debugging you can use: $ FIM_DEBUG=1 ./app.flatimage # or $ export FIM_DEBUG=1 $ ./app.flatimage","title":"How to use"},{"location":"cmd/environment/#how-it-works","text":"FlatImage defines environment variables during its boot process, they are used to convey information about the directories to mount filesystems and query data.","title":"How it works"},{"location":"cmd/environment/#appendix","text":"Details for PS1 configuration: PROMPTING When executing interactively, bash displays the primary prompt PS1 when it is ready to read a command, and the secondary prompt PS2 when it needs more input to complete a command. Bash displays PS0 after it reads a command but before executing it. Bash displays PS4 as described above before tracing each command when the -x option is enabled. Bash allows these prompt strings to be customized by inserting a number of backslash-escaped special char\u2010 acters that are decoded as follows: \\a an ASCII bell character (07) \\d the date in \"Weekday Month Date\" format (e.g., \"Tue May 26\") \\D{format} the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required \\e an ASCII escape character (033) \\h the hostname up to the first \u2018.' \\H the hostname \\j the number of jobs currently managed by the shell \\l the basename of the shell's terminal device name \\n newline \\r carriage return \\s the name of the shell, the basename of $0 (the portion following the final slash) \\t the current time in 24-hour HH:MM:SS format \\T the current time in 12-hour HH:MM:SS format \\@ the current time in 12-hour am/pm format \\A the current time in 24-hour HH:MM format \\u the username of the current user \\v the version of bash (e.g., 2.00) \\V the release of bash, version + patch level (e.g., 2.00.0) \\w the value of the PWD shell variable ($PWD), with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable) \\W the basename of $PWD, with $HOME abbreviated with a tilde \\! the history number of this command \\# the command number of this command \\$ if the effective UID is 0, a #, otherwise a $ \\nnn the character corresponding to the octal number nnn \\\\ a backslash \\[ begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt \\] end a sequence of non-printing characters The command number and the history number are usually different: the history number of a command is its position in the history list, which may include commands restored from the history file (see HISTORY below), while the command number is the position in the sequence of commands executed during the current shell session. After the string is decoded, it is expanded via parameter expansion, command substitution, arithmetic expansion, and quote re\u2010 moval, subject to the value of the promptvars shell option (see the description of the shopt command under SHELL BUILTIN COMMANDS below). This can have unwanted side effects if escaped portions of the string appear within command substitution or contain characters special to word expansion.","title":"Appendix"},{"location":"cmd/exec/","text":"Execute a command as a regular user What is it? fim-exec executes a command as a regular user inside the flatimage container, if the HOME permission is set, it also allows access to the host home directory. How to Use You can use ./app.flatimage fim-help exec to get the following usage details: Flatimage - Portable Linux Applications fim-exec: Executes a command as a regular user Usage: fim-exec program-name [program-args...] Example: fim-exec bash To run a program installed in the container: ./app.flatimage fim-exec firefox How it Works If the image is named my-app , the program data is stored in an overlay filesystem in .my-app/overlays .","title":"fim-exec"},{"location":"cmd/exec/#execute-a-command-as-a-regular-user","text":"","title":"Execute a command as a regular user"},{"location":"cmd/exec/#what-is-it","text":"fim-exec executes a command as a regular user inside the flatimage container, if the HOME permission is set, it also allows access to the host home directory.","title":"What is it?"},{"location":"cmd/exec/#how-to-use","text":"You can use ./app.flatimage fim-help exec to get the following usage details: Flatimage - Portable Linux Applications fim-exec: Executes a command as a regular user Usage: fim-exec program-name [program-args...] Example: fim-exec bash To run a program installed in the container: ./app.flatimage fim-exec firefox","title":"How to Use"},{"location":"cmd/exec/#how-it-works","text":"If the image is named my-app , the program data is stored in an overlay filesystem in .my-app/overlays .","title":"How it Works"},{"location":"cmd/layer/","text":"Manager FlatImage layers What is it? fim-layer is a command to manage the layers of a FlatImage. How to Use In this example, lets create a new layer that includes an executable to print hello world on the terminal. The first step is to create the directory structure for the layer, e.g.: $ mkdir -p ./root/usr/bin The root directory will overlay the root directory of the FlatImage, now lets create our script and make it executable: # Use bash to run the script $ echo '#!/bin/bash' > ./root/usr/bin/hello-world.sh # Print hello world with the script $ echo 'echo \"hello world\"' >> ./root/usr/bin/hello-world.sh # Make the script executable $ chmod +x ./root/usr/bin/hello-world.sh Now with the root directory configured, we can create the novel layer with: # This command creates a layer from the 'root' folder and saves # it to a file names 'layer' $ ./app.flatimage fim-layer create ./root ./layer The last step is to include the created layer in the FlatImage: $ ./app.flatimage fim-layer add ./layer Now we can test if the process succeeded with: $ ./app.flatimage fim-exec hello-world.sh hello world How it Works The create and add commands demonstrated above are similar to the fim-commit command, but allow the user to specify a specific directory to create the novel layer from.","title":"fim-layer"},{"location":"cmd/layer/#manager-flatimage-layers","text":"","title":"Manager FlatImage layers"},{"location":"cmd/layer/#what-is-it","text":"fim-layer is a command to manage the layers of a FlatImage.","title":"What is it?"},{"location":"cmd/layer/#how-to-use","text":"In this example, lets create a new layer that includes an executable to print hello world on the terminal. The first step is to create the directory structure for the layer, e.g.: $ mkdir -p ./root/usr/bin The root directory will overlay the root directory of the FlatImage, now lets create our script and make it executable: # Use bash to run the script $ echo '#!/bin/bash' > ./root/usr/bin/hello-world.sh # Print hello world with the script $ echo 'echo \"hello world\"' >> ./root/usr/bin/hello-world.sh # Make the script executable $ chmod +x ./root/usr/bin/hello-world.sh Now with the root directory configured, we can create the novel layer with: # This command creates a layer from the 'root' folder and saves # it to a file names 'layer' $ ./app.flatimage fim-layer create ./root ./layer The last step is to include the created layer in the FlatImage: $ ./app.flatimage fim-layer add ./layer Now we can test if the process succeeded with: $ ./app.flatimage fim-exec hello-world.sh hello world","title":"How to Use"},{"location":"cmd/layer/#how-it-works","text":"The create and add commands demonstrated above are similar to the fim-commit command, but allow the user to specify a specific directory to create the novel layer from.","title":"How it Works"},{"location":"cmd/perms/","text":"Configure permissions What is it? It is a functionally to allow granular access to the host's resources. How to use You can use ./app.flatimage fim-help perms to get the following usage details: fim-perms : Edit current permissions for the flatimage Commands: add,del,list, add : Allow one or more permissions del : Delete one or more permissions list : List current permissions Note: Permissions: home,media,audio,wayland,xorg,dbus_user,dbus_system,udev,usb,input,gpu,network Usage: fim-perms add <perms...> <perms> : One or more permissions Usage: fim-perms del <perms...> <perms> : One or more permissions Usage: fim-perms list Example: fim-perms add home,network,gpu To allow the access to a resource, use the add subcommand: $ ./app.flatimage fim-perms add home This will make the home directory of the host accessible from the container. To reset all permissions to a specific list of permissions, use set : $ ./app.flatimage fim-perms set media,audio,wayland,xorg,dbus_user,dbus_system,udev,usb,input,gpu,network This will allow access to the majority of resources, except home . To list the current permissions, use list : $ ./app.flatimage fim-perms list This will list all the currently set permissions. To delete a specific permission, use del : $ ./app.flatimage fim-perms del home This remove access to the host home directory. How it works FlatImage uses bubblewrap's bind mechanisms to make devices and directories available in the guest container.","title":"fim-perms"},{"location":"cmd/perms/#configure-permissions","text":"","title":"Configure permissions"},{"location":"cmd/perms/#what-is-it","text":"It is a functionally to allow granular access to the host's resources.","title":"What is it?"},{"location":"cmd/perms/#how-to-use","text":"You can use ./app.flatimage fim-help perms to get the following usage details: fim-perms : Edit current permissions for the flatimage Commands: add,del,list, add : Allow one or more permissions del : Delete one or more permissions list : List current permissions Note: Permissions: home,media,audio,wayland,xorg,dbus_user,dbus_system,udev,usb,input,gpu,network Usage: fim-perms add <perms...> <perms> : One or more permissions Usage: fim-perms del <perms...> <perms> : One or more permissions Usage: fim-perms list Example: fim-perms add home,network,gpu To allow the access to a resource, use the add subcommand: $ ./app.flatimage fim-perms add home This will make the home directory of the host accessible from the container. To reset all permissions to a specific list of permissions, use set : $ ./app.flatimage fim-perms set media,audio,wayland,xorg,dbus_user,dbus_system,udev,usb,input,gpu,network This will allow access to the majority of resources, except home . To list the current permissions, use list : $ ./app.flatimage fim-perms list This will list all the currently set permissions. To delete a specific permission, use del : $ ./app.flatimage fim-perms del home This remove access to the host home directory.","title":"How to use"},{"location":"cmd/perms/#how-it-works","text":"FlatImage uses bubblewrap's bind mechanisms to make devices and directories available in the guest container.","title":"How it works"},{"location":"cmd/root/","text":"Execute a command as a regular user What is it? fim-root executes a command as the root user inside the flatimage container. How to Use You can use ./app.flatimage fim-help root to get the following usage details: Flatimage - Portable Linux Applications fim-root: Executes a command as the root user Usage: fim-root program-name [program-args...] Example: fim-root bash To install a program in the container: # Allow network access ./app.flatimage fim-perms add network # Install firefox ./app.flatimage fim-root pacman -S firefox How it Works FlatImage uses bubblewrap to execute commands inside a containerized environment, the programs are installed in an overlay filesystem localized in the same folder as the current flatimage. If the image is named my-app , the overlay filesystem is stored in .my-app/overlays","title":"fim-root"},{"location":"cmd/root/#execute-a-command-as-a-regular-user","text":"","title":"Execute a command as a regular user"},{"location":"cmd/root/#what-is-it","text":"fim-root executes a command as the root user inside the flatimage container.","title":"What is it?"},{"location":"cmd/root/#how-to-use","text":"You can use ./app.flatimage fim-help root to get the following usage details: Flatimage - Portable Linux Applications fim-root: Executes a command as the root user Usage: fim-root program-name [program-args...] Example: fim-root bash To install a program in the container: # Allow network access ./app.flatimage fim-perms add network # Install firefox ./app.flatimage fim-root pacman -S firefox","title":"How to Use"},{"location":"cmd/root/#how-it-works","text":"FlatImage uses bubblewrap to execute commands inside a containerized environment, the programs are installed in an overlay filesystem localized in the same folder as the current flatimage. If the image is named my-app , the overlay filesystem is stored in .my-app/overlays","title":"How it Works"},{"location":"examples/steam/","text":"Create a Portable Steam Installation Here is the process to create a portable installation of steam, that can be stored in an external hard-drive to use across different computers without hassle. wget -Osteam.sh https://raw.githubusercontent.com/ruanformigoni/flatimage/refs/heads/master/examples/steam.sh chmod +x steam.sh ./steam.sh This will generate a steam.flatimage package, which will store all the information in the .steam.flatimage.config hidden folder. You can move this binary to an external hard-drive and use the same steam installation on different linux distributions without worrying about dependency/installation issues. Furthermore, all your games will be installed to .steam.flatimage.config . Here is the details of the executed script: #!/bin/bash set -e function _die() { echo \"$*\" >&2 kill -s TERM \"$$\" } function _requires() { for i; do command -v \"$i\" &>/dev/null || _die \"Dependency '$i' not found, please install it separately\" done } function _main() { _requires \"tar\" \"wget\" \"xz\" mkdir -p build && cd build # Use jq to fetch latest flatimage version from github mkdir -p bin export PATH=\"$(pwd)/bin:$PATH\" wget -q --show-progress --progress=dot:binary -O bin/jq https://github.com/jqlang/jq/releases/download/jq-1.7/jq-linux-amd64 chmod +x ./bin/* # TODO # Enable network \"$image\" fim-perms set network # Update image \"$image\" fim-root pacman -Syu --noconfirm # Install dependencies ## General \"$image\" fim-root pacman -S --noconfirm xorg-server mesa lib32-mesa glxinfo lib32-gcc-libs \\ gcc-libs pcre freetype2 lib32-freetype2 ## Video AMD/Intel \"$image\" fim-root pacman -S --noconfirm xf86-video-amdgpu vulkan-radeon lib32-vulkan-radeon vulkan-tools \"$image\" fim-root pacman -S --noconfirm xf86-video-intel vulkan-intel lib32-vulkan-intel vulkan-tools # Install steam ## Select the appropriated drivers for your GPU when asked \"$image\" fim-root pacman -S --noconfirm steam # Clear cache \"$image\" fim-root fakechroot pacman -Scc --noconfirm # Set permissions \"$image\" fim-perms set media,audio,wayland,xorg,udev,dbus_user,usb,input,gpu,network # Configure user name and home directory \"$image\" fim-exec mkdir -p /home/steam \"$image\" fim-env set 'PATH=\"/usr/bin:$PATH\"' \\ 'USER=steam' \\ 'HOME=/home/steam' \\ 'XDG_CONFIG_HOME=/home/steam/.config' \\ 'XDG_DATA_HOME=/home/steam/.local/share' # Set command to run by default \"$image\" fim-boot /usr/bin/steam # Compress \"$image\" fim-commit # Copy cp \"$image\" ../steam } _main \"$@\"","title":"Steam"},{"location":"examples/steam/#create-a-portable-steam-installation","text":"Here is the process to create a portable installation of steam, that can be stored in an external hard-drive to use across different computers without hassle. wget -Osteam.sh https://raw.githubusercontent.com/ruanformigoni/flatimage/refs/heads/master/examples/steam.sh chmod +x steam.sh ./steam.sh This will generate a steam.flatimage package, which will store all the information in the .steam.flatimage.config hidden folder. You can move this binary to an external hard-drive and use the same steam installation on different linux distributions without worrying about dependency/installation issues. Furthermore, all your games will be installed to .steam.flatimage.config . Here is the details of the executed script: #!/bin/bash set -e function _die() { echo \"$*\" >&2 kill -s TERM \"$$\" } function _requires() { for i; do command -v \"$i\" &>/dev/null || _die \"Dependency '$i' not found, please install it separately\" done } function _main() { _requires \"tar\" \"wget\" \"xz\" mkdir -p build && cd build # Use jq to fetch latest flatimage version from github mkdir -p bin export PATH=\"$(pwd)/bin:$PATH\" wget -q --show-progress --progress=dot:binary -O bin/jq https://github.com/jqlang/jq/releases/download/jq-1.7/jq-linux-amd64 chmod +x ./bin/* # TODO # Enable network \"$image\" fim-perms set network # Update image \"$image\" fim-root pacman -Syu --noconfirm # Install dependencies ## General \"$image\" fim-root pacman -S --noconfirm xorg-server mesa lib32-mesa glxinfo lib32-gcc-libs \\ gcc-libs pcre freetype2 lib32-freetype2 ## Video AMD/Intel \"$image\" fim-root pacman -S --noconfirm xf86-video-amdgpu vulkan-radeon lib32-vulkan-radeon vulkan-tools \"$image\" fim-root pacman -S --noconfirm xf86-video-intel vulkan-intel lib32-vulkan-intel vulkan-tools # Install steam ## Select the appropriated drivers for your GPU when asked \"$image\" fim-root pacman -S --noconfirm steam # Clear cache \"$image\" fim-root fakechroot pacman -Scc --noconfirm # Set permissions \"$image\" fim-perms set media,audio,wayland,xorg,udev,dbus_user,usb,input,gpu,network # Configure user name and home directory \"$image\" fim-exec mkdir -p /home/steam \"$image\" fim-env set 'PATH=\"/usr/bin:$PATH\"' \\ 'USER=steam' \\ 'HOME=/home/steam' \\ 'XDG_CONFIG_HOME=/home/steam/.config' \\ 'XDG_DATA_HOME=/home/steam/.local/share' # Set command to run by default \"$image\" fim-boot /usr/bin/steam # Compress \"$image\" fim-commit # Copy cp \"$image\" ../steam } _main \"$@\"","title":"Create a Portable Steam Installation"}]}